# 1.什么是面向对象
与面向过程是两种不同的处理问题方式，面向过程更注重事情的步骤和顺序，面向对象更注重事情的参与者及各自需要做什么。

比如：用洗衣机洗衣服
面向过程的思考方式：打开洗衣机->放衣服->放洗衣液->清洗->脱水
面向对象的思考方式：需要人（打开洗衣机，放衣服，放洗衣液）和洗衣机（清洗，脱水）
面向过程比较直接高效，面向对象更易于复用、扩展和维护。

面向对象的三大特性：
封装：封装的意义在于明确标识出允许外部使用的所有变量和方法
继承：继承基类的变量和方法，并可以进行自己的扩展
多态：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同

# 2.JDK、JRE和JVM
JDK：java开发工具
JRE：java运行环境
JVM：java虚拟机
JRE = JVM + 类库
JDK = JRE + 工具（javac、java、jconsole）

# 3.==和equals
==：对于基本数据类型比较的是值，对于引用类型比较的的内存地址
equals：默认是采用==，一般会被重写

# 4.final
修饰类：表示类不可被继承
修饰方法：表示方法不可被子类重写
修饰变量：表示变量一旦被赋值就不能修改

为什么局部内部类和匿名内部类只能访问final修饰的局部变量？
内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕而销毁。
这里会产生一个问题，当外部类的方法执行结束时，局部变量就会被销毁，但此时内部类可以还要访问该变量。为类解决这个问题，将局部变量复制了一份作为内部类的成员变量，当局部变量被销毁后，依然可以访问。这样会产生一个新的问题，怎么保证两个变量的一致性，就是将局部变量设置为final，一旦初始化不让再修改。

# 5.String、StringBuilder和StringBuffer
String是final修饰的不可变，每次操作都会产生一个新的对象
StringBuilder和StringBuffer是在原对象上操作
StringBuffer是线程安全的，方法都是synchronized修饰的

# 6.重载和重写
重载：发生在同一个类中，方法名必须相同，参数列表必须不同，返回值和访问修饰法可以不同
重写：发生在父子类中，方法名和参数列表必须相同，返回值范围小于等于父类，抛出异常范围小于等于父类，访问修饰法大于等于父类

# 7.接口和抽象类
抽象类可以存在普通方法，而接口只能存在public abstract方法
抽象类的成员变量可以是各种类型，而接口的成员变量只能是public static final类型的
抽象类只能单继承，而接口可以多实现

抽象类的设计目的，是代码的复用。当不同的类具有某些相同的行为，且一部分行为的实现方式一致时，可以让这些类派生于一个抽象类。抽象类是对类本质的抽象，表达的是is a的关系。
接口的设计目的，是对类的行为进行约束。也就是提供一种机制，可以强制要求不同的类具有相同的行为，它只约束行为的有无，但不对具体实现进行限制。接口是对行为的抽象，表达的是like a的关系。


# 1.ArrayList和LinkList的区别
1. 它们的底层数据结构不同，ArrayList底层基于数组实现，LinkList底层基于链表实现。
2. 由于底层数据结构不同，它们的使用场景不同，ArrayList更适合随机查找，LinkList更适合添加和删除。
3. 它们都实现了List接口，LinkList还额外实现了Deque接口，所以LinkList可以当作队列使用。