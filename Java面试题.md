# 1.什么是面向对象
与面向过程是两种不同的处理问题方式，面向过程更注重事情的步骤和顺序，面向对象更注重事情的参与者及各自需要做什么。

比如：用洗衣机洗衣服
面向过程的思考方式：打开洗衣机->放衣服->放洗衣液->清洗->脱水
面向对象的思考方式：需要人（打开洗衣机，放衣服，放洗衣液）和洗衣机（清洗，脱水）
面向过程比较直接高效，面向对象更易于复用、扩展和维护。

面向对象的三大特性：

封装：封装的意义在于明确标识出允许外部使用的所有变量和方法

继承：继承基类的变量和方法，并可以进行自己的扩展

多态：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同

# 2.JDK、JRE和JVM
JDK：java开发工具

JRE：java运行环境

JVM：java虚拟机

JRE = JVM + 类库

JDK = JRE + 工具（javac、java、jconsole）

# 3.==和equals
==：对于基本数据类型比较的是值，对于引用类型比较的的内存地址

equals：默认是采用==，一般会被重写

# 4.final
修饰类：表示类不可被继承

修饰方法：表示方法不可被子类重写

修饰变量：表示变量一旦被赋值就不能修改

为什么局部内部类和匿名内部类只能访问final修饰的局部变量？

内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕而销毁。这里会产生一个问题，当外部类的方法执行结束时，局部变量就会被销毁，但此时内部类可以还要访问该变量。为类解决这个问题，将局部变量复制了一份作为内部类的成员变量，当局部变量被销毁后，依然可以访问。这样会产生一个新的问题，怎么保证两个变量的一致性，就是将局部变量设置为final，一旦初始化不让再修改。

# 5.String、StringBuilder和StringBuffer
String是final修饰的不可变，每次操作都会产生一个新的对象

StringBuilder和StringBuffer是在原对象上操作

StringBuffer是线程安全的，方法都是synchronized修饰的

# 6.重载和重写
重载：发生在同一个类中，方法名必须相同，参数列表必须不同，返回值和访问修饰法可以不同

重写：发生在父子类中，方法名和参数列表必须相同，返回值范围小于等于父类，抛出异常范围小于等于父类，访问修饰法大于等于父类

# 7.接口和抽象类
抽象类可以存在普通方法，而接口只能存在public abstract方法

抽象类的成员变量可以是各种类型，而接口的成员变量只能是public static final类型的

抽象类只能单继承，而接口可以多实现

抽象类的设计目的，是代码的复用。当不同的类具有某些相同的行为，且一部分行为的实现方式一致时，可以让这些类派生于一个抽象类。抽象类是对类本质的抽象，表达的是is a的关系。

接口的设计目的，是对类的行为进行约束。也就是提供一种机制，可以强制要求不同的类具有相同的行为，它只约束行为的有无，但不对具体实现进行限制。接口是对行为的抽象，表达的是like a的关系。

# 8.ArrayList和LinkList的区别
1. 它们的底层数据结构不同，ArrayList底层基于数组实现，LinkList底层基于链表实现；
2. 由于底层数据结构不同，它们的使用场景不同，ArrayList更适合随机查找，LinkList更适合添加和删除；
3. 它们都实现了List接口，LinkList还额外实现了Deque接口，所以LinkList可以当作队列使用。

# 9.HashMap和HashTable的区别
1. HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；
2. HashMap允许key和value为null，HashTable不允许。

HashMap底层实现为数组+链表，数组是HashMap的主体，链表是为了解决哈希冲突而存在的。HashMap通过调用key所属类的hashCode方法计算出key的hash值，然后将hash值通过哈希函数计算出更加复杂的hash值，再将算出的hash值和数组长度进行&运算，获得在Entry数组中存放的位置。此时有两种情况：
1. 该数组位置上是空的，此时直接将键值对存放；
2. 该数组位置上不为空，此时就需要将key的哈希值和该位置上存放的所有元素的key的哈希值逐一进行比较。如果哈希值都不同，认为键值对是一个新的元素，继续以链表的形式存储；如果哈希值相同，还需要调用key的equals方法进行比较，如果equals后返回true，则证明这两个key是相同的，用新的value值替换旧的value值，如果equals后返回false，则证明这两个key是不同的，继续以链表的形式存储。

# 10.HashMap的容量为什么是2的幂次方
```java
// 计算key在HashMap中数组位置的过程
// 首先获取key的hashcode值
h = hashcode()
// 然后将hashcode值右移16位，再与自己做异或运算
hash = h ^ (h >>> 16)
// 所得的结果和HashMap的容量减1做与运算
index = (n-1) & hash
```
HashMap的容量为2的幂次方，与（n-1）& hash有关。因为只有当对应的位置都为1，与运算结果才为1，使得添加的元素均匀分布在HashMap的每个位置上，减少hash碰撞。

# 11.Java类加载器
Java自带有三个类加载器：
1. BootstarpClassLoader是ExtClassLoader的父加载器，负责加载%JAVA_HOME%/lib下的jar包和class文件；
2. ExtClassLoader是AppClassLoader的父加载器，负责加载%JAVA_HOME%/lib/ext下的jar包和class文件；
3. AppClassLoader是自定义类加载器的父加载器，负责加载classpath下的class文件。

# 12.双亲委派机制
加载一个类的过程，先是向上委派（查找缓存，是否加载了该类，有则直接返回，没有继续向上），委派到顶层之后，缓存中依然没有找到，则到加载路径中查找，有则加载返回，没有则向下查找。

双亲委派的好处：
1. 主要是为了安全性，避免用户自己编写的类动态替换Java的核心类；
2. 避免类的重复加载，JVM中区分不同类，不仅仅是根据类名，相同的class文件被不同的Classload加载就是两个不同的类。

# 13.Java的异常体系
Java中所有异常都来自顶级父类Throwable，Throwable有两个子类Error和Exception
1. Error无法通过程序处理的错误，一旦出现程序就会被迫停止；
2. Exception可以通过程序处理的错误，它又分为RunTimeException和CheckedException。RunTimeException发生在程序运行过程中，会导致程序当前线程执行失败；CheckedException发生在编译过程中，导致编译不通过。

# 14.GC如何判断对象可以被回收
1. 引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计算为0时可以回收；引用计算法可以会出现互相引用，a引用b，b引用a，导致永远无法回收；
2. 可达性分析法：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则该对象可以回收。

GC Roots的对象有：
1. JVM栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI引用的对象

# 15.线程的生命周期
线程有五种状态：
1. 新建状态（New）：新创建一个线程对象
2. 就绪状态（Runnable）：线程对象创建后，调用该对象的start()。该状态的线程位于可运行线程池中，变得可用行，等待获取CPU的使用权
3. 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码
4. 阻塞状态（Blocked）：线程因为某种原因放弃CPU的使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态
5. 死亡状态（Dead）：线程执行完毕或异常退出run(),线程生命周期结束

阻塞分三种情况：
1. 等待阻塞：运行的线程执行了wait()，该线程会释放占用的所有资源，JVM会把线程放入“等待池”中，必须依靠其他线程调用notify()或notifyAll()才能被唤醒
2. 同步阻塞：运行的线程中获取对象的同步锁时，若该同步锁被其他线程占用，JVM会把线程放入“锁池”中
3. 其他阻塞：运行的线程执行了sleep()、join()、发出了I/O请求时，JVM会把线程置为阻塞状态。当sleep超时、join等待线程终止或超时、I/O处理完毕时，线程重新进入就绪状态



